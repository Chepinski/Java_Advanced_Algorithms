Questions:
What is the Barabasi model and why is it important?
Research DAG (Directed acyclic graphs (for DFS))


Notes:
BFS is important in web crawling.

DFS takes same time whether recursive or iterative.  Java will use stack for both.

DFS = stack (mehr memory friendly)
BFS = queue

toString method can always be overridden

DAG directed acyclic graph..a graph with no directed cycles
topological sort has linear time complexity

Hamiltonian path?

topological order
	find edge with no incoming edges
	then find next edge with no incoming edges
		(edges already counted do not count as an incoming edge)
	repeat until done
	
	gives us the steps in order we have to take to complete a task.
	no task can be completed until the previous steps (incoming edges) are completed
		-dependency management (Maven)
		-syllabus für Uni
		
Cycle = we are visiting again a vertex that is being visited

O(N) items (leaf nodes) in queue, if graph has N - BFS (good for artificial intelligence/robot movements
	because it searches through the entire local area.
O(logN) items, so more memory friendly and preferred - DFS

Shortest Path algorithms
finding a shortest path between two vertices in a graph
	-Dijkstra
		Edsger Dijkstra 1956
		positive edge weights only
		asymptotically fastest single-source shortest-path algorithm
		if source changes, needs recalculation
		O(V*log(V)+E) V=verteces E=edges
		greedy algorithm/tries to find min distance between all verteces
		
		Adjacency matrixes help Dijkstra
	-Bellman Ford
		Bellman and Ford (independently) 1958
		slower but can handle negative edge weights as well
		V-1 iterations running O(V*E)
		V-1 +1 to detect cycles
		no negative cycles IRL but sometimes problems (forex, stock market)
			are given negative edges
			
DAG (directed acyclic[no cyles] graph) shortest path algorithm
	-topological sorting DFS O(E+V), much faster than Dijkstra & Bellman-Ford
	-solving Knapsack-problem application, GPS, vehicles routing, navigation
	-RIP (Routing Information Protocol)??  WWW wants to send packets on the shortest path possible
	
	Avidan-Shamir method
		-shrink an image e.g. on a browser without distortion
		-Photoshop/GIMP
			vertices are pixels and edges point to downward 3 neighbors

Disjoint sets (union-find)
	3 operations: union, find, makeSet
	O(1) is vertex in the same set?
	makeSet
		function makeSet(x)
			x.parent = x //item is set as own parent
	find
		function find(x)
			if x.parent == x
				return x
			else 
				return find(x.parent)  //if x.parent = itself is root node
	union
		function union(x,y)
			xRoot= find(x)
			yRoot = find(y)
			x.Root.parent = yRoot
			//Problem: tree like structures like binary search can become unbalanced
	used in Kruskal-algorithm
	can check for cycle in asymptotically O(1)

Kruskal-algorithm
	-sort the edges according to edge weights
	-can be done in O(N*logN) with mergesort or quicksort
		worst-case running time O(E*logE)
	-union find data structure/"disjoint set"
Prims algorithm
	-vertex (as opposed to Kruskal)
	-two types: lazy and eager
	-heap used
	-faster in the limit when graph is dense (more edges than vertices)
	-Kruskal better in typical situations and uses simpler data structures
	-good for things like connecting N cities at the lowest cost
		cities are vertexes and roads are vertexes
	-k-means clustering
		classify similar items
		machine learning
		dots closer to each other than any other dots in same cluster
	-routing in LAN
		(STP) spanning tree protocol/loop-free topology

Strongly connected graph
	-strongly connected if can get from any vertex to another (e.g. undirected graph)
	-directed graphs CANNOT be reached from any vertex
		may be connected but not strongly connected
	-we can find this in O(v)
	-we can shrink strongly graph into 1 vertex
	Kosaraju algorithm
		-uses 2 DFS's
		-transpose the graph (reverse the edges)
	Tarjan algorithm
		-uses 1 DFS
		-more popular
		*both algorithms useful for:
			-ecology: determining hierarchy of food needs
			-software engineering: package large software using strongly connected classes
			-astrophysics: detect faint stars by clustering them
			-youtube: recommend based on connected components/clusters	
	
